---
description: Conventions de code backend (Express, Sequelize)
globs: backend/**/*.js
alwaysApply: false
---

# Conventions Backend

## Structure des Controllers

### Pattern Standard
```javascript
const Model = require('../models/Model');
const { Op } = require('sequelize');

exports.actionName = async (req, res) => {
    try {
        // Validation des données
        if (!req.body.requiredField) {
            return res.status(400).json({
                error: 'Le champ requiredField est requis',
            });
        }
        
        // Logique métier
        const result = await Model.findAll({
            where: { /* conditions */ },
            order: [['id', 'ASC']]
        });
        
        // Réponse succès
        res.json({ data: result });
    } catch (error) {
        console.error('Erreur lors de l\'action:', error);
        res.status(500).json({ 
            error: 'Erreur serveur', 
            details: error.message 
        });
    }
};
```

### Règles
- Toujours utiliser `async/await`
- Toujours wrapper dans `try/catch`
- Logger les erreurs avec `console.error()` avant de répondre
- Retourner des objets JSON cohérents : `{ error: '...' }` ou `{ data: ... }`
- Utiliser `return res.status(...)` pour arrêter l'exécution après une erreur

## Structure des Routes

```javascript
const express = require('express');
const route = express.Router();
const controller = require('../controllers/controller');

route.get('/endpoint', controller.action);
route.post('/endpoint', controller.action);
route.put('/endpoint/:id', controller.action);
route.delete('/endpoint/:id', controller.action);

module.exports = route;
```

### Intégration dans app.js
```javascript
app.use('/api', require('./router/test.route'));
app.use('/api/payment', require('./router/payment.route'));
```

## Services (Logique Métier Pure)

### Pattern
```javascript
class ServiceName {
  async methodName(param1, param2 = 'default') {
    try {
      // Logique pure (pas de req/res)
      const result = await externalApi.call();
      return { success: true, data: result };
    } catch (error) {
      console.error('Erreur dans ServiceName.methodName:', error);
      throw new Error(`Erreur: ${error.message}`);
    }
  }
}

module.exports = new ServiceName();
```

### Règles
- Services = logique métier réutilisable
- Pas d'accès direct à `req`/`res`
- Retourner des objets ou throw des erreurs
- Utiliser des classes pour regrouper les méthodes liées

## Modèles Sequelize

### Pattern Standard
```javascript
const { sequelize } = require('../config/database');
const { DataTypes } = require('sequelize');

const ModelName = sequelize.define(
  'table_name',  // Nom de la table en DB
  {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      primaryKey: true,
    },
    field_name: {
      type: DataTypes.TEXT,
      allowNull: true,
    },
  },
  {
    tableName: 'table_name',      // Nom EXACT de la table
    freezeTableName: true,         // Empêche Sequelize de modifier le nom
    timestamps: false,            // Pas de createdAt/updatedAt si non présents
  }
);

module.exports = ModelName;
```

### Règles
- Toujours utiliser `freezeTableName: true` pour éviter les modifications de nom
- Spécifier `tableName` explicitement
- Utiliser `timestamps: false` si les colonnes n'existent pas en DB
- Importer `sequelize` depuis `config/database.js`

## Requêtes Sequelize

### Pattern de Recherche
```javascript
const { Op } = require('sequelize');

const results = await Model.findAll({
  where: {
    id: { [Op.between]: [1, 10] },
    // ou
    field: { [Op.like]: '%search%' },
  },
  order: [['id', 'ASC']],
  limit: 10,
});
```

### Règles
- Utiliser les opérateurs Sequelize (`Op.between`, `Op.like`, etc.)
- Toujours spécifier `order` pour la cohérence
- Utiliser `limit` pour les grandes listes

## Gestion des Erreurs

### Dans les Controllers
```javascript
// ✅ BON
try {
  // code
} catch (error) {
  console.error('Contexte de l\'erreur:', error);
  res.status(500).json({ 
    error: 'Message utilisateur', 
    details: error.message 
  });
}
```

### Dans les Services
```javascript
// ✅ BON
try {
  // code
} catch (error) {
  console.error('Erreur dans Service.method:', error);
  throw new Error(`Erreur descriptive: ${error.message}`);
}
```

## Configuration Express

### app.js Pattern
```javascript
require('dotenv').config();
const express = require('express');
const app = express();
const cors = require('cors');

// CORS configuré avec variables d'env
app.use(cors({
  origin: process.env.CORS_ORIGIN,
  credentials: true,
  methods: ['GET','POST','PUT','DELETE','OPTIONS'],
  allowedHeaders: ['Content-Type','Authorization','X-CSRF-Token']
}));

app.use(express.json());
app.use(express.urlencoded({ extended: false })); // ⚠️ Ne pas mettre true

// Routes
app.use('/api', require('./router/test.route'));

// Database
const { connectToDB, connectModels } = require('./config/database');
connectToDB();
connectModels({ force: false });

module.exports = app;
```

### Règles
- Toujours charger `dotenv` en premier
- CORS configuré avec variables d'environnement
- `extended: false` pour `urlencoded` (évite problèmes avec BDD)
- Connecter la DB après la configuration des routes
